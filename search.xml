<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一键部署 Hexo 博客到 GitHub Pages</title>
    <url>/posts/6f0712da.html</url>
    <content><![CDATA[<p><a href="https://hexo.io/">Hexo</a> 是一个快速、简洁且高效的博客框架，只需一条指令即可部署到 GitHub Pages, Heroku 或其他平台<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。</p>
<p>如果没有什么特殊的需求，将生成的静态网页托管到 <a href="https://pages.github.com/">GitHub Pages</a> 是一个不错的选择。目前 Hexo 官方提供了2种方式一键部署到 GitHub Pages：</p>
<ul>
<li>本地一键部署：使用 Hexo 官方的部署插件 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a></li>
<li>远程一键部署：使用 GitHub 自家的 <a href="https://en.wikipedia.org/wiki/CI/CD">CI/CD</a> 工具 <a href="https://docs.github.com/zh/actions">GitHub Actions</a></li>
</ul>
<p>这两种方式对应了不同的使用场景，第一种方式适合博客源代码没有托管在 GitHub 的场景，第二种相反。博主选择了将博客源代码托管到了 GitHub，所以很自然的选择了第二种方式实现一键部署的需求，接下来具体看看如何利用 CI/CD 工具实现远程一键部署 Hexo 博客到 GitHub Pages。</p>
<h2 id="一键部署博客">一键部署博客</h2>
<p>博主在几年前就接触了 Hexo 博客，当时 GitHub Actions 的正式版才推出不久(2019/11/13)<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>，参考了<a href="https://github.com/formulahendry">韩骏</a>大佬的博客<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>使用了 <a href="https://www.appveyor.com/">AppVeyor</a> 作为 CI/CD 工具，只可惜其免费版本不支持私有仓库。博客源代码仓库包含了非公开的配置信息(服务的<code>token</code>、<code>secret</code>)以及加密文章的原文、草稿箱的草稿，因此源代码仓库设置为私有是必要的。而 GitHub Actions 作为 GitHub 自家的产品，对于当前的使用场景即使是私有仓库也完美支持。有一点需要注意的是对于私有仓库 GitHub Actions 有额度限制，不过即使是最低级别的 GitHub Free 也有相当可观的额度，具体可以查阅<a href="https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions">官方文档</a>。</p>
<p>选定 GitHub Actions 作为 CI/CD 工具后查阅 Hexo 官方给定的<a href="https://hexo.io/docs/github-pages">文档</a>发现其设定是博客源代码与 GitHub Pages 储存在同一个仓库通过分支进行区分，但将 GitHub Pages 所在的仓库设置为私有需要订阅更高级别的产品<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>，这显然与我们的需求不符。</p>
<blockquote>
<p>GitHub Pages is available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see "<a href="https://docs.github.com/en/get-started/learning-about-github/githubs-products">GitHub’s products</a>."</p>
</blockquote>
<p>通过查阅 Hexo 官方配置文件中复用的 Action <code>peaceiris/actions-gh-pages@v3</code>的<a href="https://github.com/marketplace/actions/github-pages-action">文档</a>发现，经过简单配置和修改就可以实现我们的需求。</p>
<blockquote>
<p>By default, your files are published to the repository which is running this action. If you want to publish to another repository on GitHub, set the environment variable <code>external_repository</code> to <code>&lt;username&gt;/&lt;external-repository&gt;</code>.</p>
</blockquote>
<p>先分别贴上原版的配置文件和修改后的配置文件：</p>
<ul>
<li><p>原版配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span>  <span class="comment"># default branch</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">pages:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">permissions:</span></span><br><span class="line">      <span class="attr">contents:</span> <span class="string">write</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="comment"># If your repository depends on submodule, please see: https://github.com/actions/checkout</span></span><br><span class="line">          <span class="attr">submodules:</span> <span class="string">recursive</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">16.</span><span class="string">x</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;16&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">NPM</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.OS</span> <span class="string">&#125;&#125;-npm-cache</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改后的配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line"> </span><br><span class="line"> <span class="attr">on:</span></span><br><span class="line">   <span class="attr">push:</span></span><br><span class="line">     <span class="attr">branches:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">main</span>  <span class="comment"># default branch</span></span><br><span class="line"> </span><br><span class="line"> <span class="attr">jobs:</span></span><br><span class="line">   <span class="attr">deploy-gh-pages:</span></span><br><span class="line">     <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">     <span class="attr">permissions:</span></span><br><span class="line">       <span class="attr">contents:</span> <span class="string">write</span></span><br><span class="line">     <span class="attr">steps:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">         <span class="attr">with:</span></span><br><span class="line">           <span class="attr">token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">           <span class="comment"># If your repository depends on submodule, please see: https://github.com/actions/checkout</span></span><br><span class="line">           <span class="attr">submodules:</span> <span class="string">recursive</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">pandoc</span></span><br><span class="line">         <span class="attr">run:</span> <span class="string">sudo</span> <span class="string">apt-get</span> <span class="string">install</span> <span class="string">pandoc</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">19.</span><span class="string">x</span></span><br><span class="line">         <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">         <span class="attr">with:</span></span><br><span class="line">           <span class="attr">node-version:</span> <span class="string">&#x27;19&#x27;</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">NPM</span> <span class="string">dependencies</span></span><br><span class="line">         <span class="attr">uses:</span> <span class="string">actions/cache@v2</span></span><br><span class="line">         <span class="attr">with:</span></span><br><span class="line">           <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">           <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.OS</span> <span class="string">&#125;&#125;-npm-cache</span></span><br><span class="line">           <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">             $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span></span><br><span class="line"><span class="string"></span>       <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">         <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">         <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">         <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">         <span class="attr">with:</span></span><br><span class="line">           <span class="attr">deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ACTIONS_DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">           <span class="attr">external_repository:</span> <span class="string">username/external-repository</span></span><br><span class="line">           <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br><span class="line">           <span class="attr">user_name:</span> <span class="string">&#x27;github-actions[bot]&#x27;</span></span><br><span class="line">           <span class="attr">user_email:</span> <span class="string">&#x27;github-actions[bot]@users.noreply.github.com&#x27;</span></span><br><span class="line">           <span class="attr">commit_message:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.event.head_commit.message</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>与原版的配置文件对比只修改了以下3个方面：</p>
<ol type="1">
<li>安装 <a href="https://pandoc.org/">pandoc</a> ： <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># line 19</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">pandoc</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">sudo</span> <span class="string">apt-get</span> <span class="string">install</span> <span class="string">pandoc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>与此文无关，因渲染器改为了<code>hexo-renderer-pandoc</code></li>
</ul></li>
<li>修改 Node.js 主版本： <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># line 21</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">19.</span><span class="string">x</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">node-version:</span> <span class="string">&#x27;19&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在本地使用<code>node --version</code>查看即可</li>
</ul></li>
<li>配置<code>peaceiris/actions-gh-pages@v3</code>的传入参数： <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># line 36</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ACTIONS_DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">external_repository:</span> <span class="string">username/external-repository</span></span><br><span class="line">    <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br><span class="line">    <span class="attr">user_name:</span> <span class="string">&#x27;github-actions[bot]&#x27;</span></span><br><span class="line">    <span class="attr">user_email:</span> <span class="string">&#x27;github-actions[bot]@users.noreply.github.com&#x27;</span></span><br><span class="line">    <span class="attr">commit_message:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.event.head_commit.message</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除<code>github_token</code>：对于<code>external_repository</code>使用<code>external_repository</code>或<code>personal_token</code>代替</li>
<li>增加<code>deploy_key</code>：生成<code>SSH Key Pair</code>，在 GitHub Pages 仓库使用公钥设置<code>Deploy keys</code>并确保勾选<code>Allow write access</code>，在博客源代码仓库的<code>Actions secrets and variables</code>设置项使用私钥设置<code>Secrets</code>。配置文件里的<code>ACTIONS_DEPLOY_KEY</code>就是之前设置<code>Secrets</code>填的名字</li>
<li>增加<code>external_repository</code>：GitHub Pages 仓库<code>username/external-repository</code></li>
<li>增加<code>user_name</code>：配置 GitHub Pages 仓库的 commit 用户为<code>github-actions[bot]</code></li>
<li>增加<code>user_email</code>：配置 GitHub Pages 仓库的 commit 用户邮箱为<code>github-actions[bot]</code>邮箱</li>
<li>增加<code>commit_message</code>：配置 GitHub Pages 仓库的 commit message 为触发该 GitHub Actions 事件源的头部 commit message</li>
</ul></li>
</ol>
<p>修改完配置文件后将配置文件存放到博客源代码仓库的<code>.github/workflows/filename.yml</code>，以后有提交 push 到该仓库的<code>main</code>分支便可触发该配置文件对应的工作流完成 GitHub Pages 的自动部署。</p>
<h2 id="一键推送源码">一键推送源码</h2>
<p>至此似乎已经大功告成，但博主觉得已经完成建站进入正常更新状态的博客，每次更新还需要<code>git add</code>、<code>git commit</code>、<code>git push</code>三个步骤才能完成博客更新还是略微麻烦，有没有办法能实现一键推送博客源代码？</p>
<h3 id="使用-hexo-deployer">使用 Hexo Deployer</h3>
<p><code>Hexo Deployer</code>是 Hexo 自带的部署工具，通过编写安装各种各样的 Hexo 插件，可以通过<code>hexo deploy</code>命令将 Hexo 博客一键部署到各种类型的托管服务，<code>Hexo Deployer</code>提供了 <a href="https://hexo.io/zh-cn/api/deployer">API</a> 供开发者开发第三方插件实现该功能。</p>
<p>虽然 Hexo 官方的本意是部署博客，但似乎可以借助这个功能实现我们一键推送源码的需求，于是博主根据 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a> 编写了一个 Hexo 插件 <a href="https://github.com/ChiuJun/hexo-auto-push-git">hexo-auto-push-git</a> ：</p>
<ol type="1">
<li><p>安装</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install https://github.com/ChiuJun/hexo-auto-push-git.git --save-dev</span><br></pre></td></tr></table></figure></p></li>
<li><p>配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># You can use this:</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">branch:</span> [<span class="string">branch</span>]</span><br><span class="line">  <span class="attr">message:</span> [<span class="string">message</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="使用-alias-shell">使用 alias shell</h3>
<p>修改完博客配置希望看看效果，每次都要输入一串命令</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></p>
<p>想到可以用<code>alias</code>简化操作，突然想到<code>alias</code>也可以完成我们一键推送源码的需求</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias hexo_test=&quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server&quot;</span><br><span class="line">alias hexot=hexo_test</span><br><span class="line">alias hexo_post_article_to_source_repo=&quot;git add -A &amp;&amp; git commit -m \&quot;docs: site updated `date \&quot;+%Y-%m-%d %H:%M:%S\&quot;`\&quot; &amp;&amp; git push -u origin HEAD:main&quot;</span><br><span class="line">alias hexop=hexo_post_article_to_source_repo</span><br></pre></td></tr></table></figure></p>
<p>将后面两行<code>alias</code>命令添加到所使用 shell 的配置文件中，使用<code>source</code>命令更新下配置文件便可以使用别名<code>hexop</code>一键推送源码 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexop</span><br></pre></td></tr></table></figure> 至此，我们已经完成了一键推送源码以及一键部署博客，以后便可以愉快的写博客了！</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Hexo (2023a) <em>Home page</em> , <em>Hexo</em>. Available at: https://hexo.io/zh-cn/ (Accessed: 08 July 2023).<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Niyogi, S. (2019) <em>New from universe 2019: Github for mobile, GitHub Archive Program, and more</em>, <em>The GitHub Blog</em>. Available at: https://github.blog/2019-11-13-universe-day-one/#github-actions (Accessed: 08 July 2023).<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Han, J. (2017) <em>Hexo的版本控制与持续集成</em>, <em>formulahendry</em>. Available at: https://formulahendry.github.io/2016/12/04/hexo-ci/ (Accessed: 08 July 2023).<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>GitHub, Inc. (no date) <em>About GitHub Pages</em>, <em>GitHub Docs</em>. Available at: https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages (Accessed: 09 July 2023).<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>参考与指南</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub Actions</tag>
        <tag>CI/CD</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Commit message 和 Change log 编写指南</title>
    <url>/posts/ad81da89.html</url>
    <content><![CDATA[<blockquote>
<p>转载信息：<a href="https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南</a>（https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html）<br />
原文作者：<a href="https://www.ruanyifeng.com/">阮一峰</a>（https://www.ruanyifeng.com/）<br />
版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>）<br />
发表日期：2016年 1月 6日</p>
</blockquote>
<p>Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码的<code>-m</code>参数，就是用来指定 commit mesage 的。</p>
<p>如果一行不够，可以只执行<code>git commit</code>，就会跳出文本编辑器，让你写多行。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></table></figure>
</blockquote>
<p>基本上，你写什么都行（<a href="http://www.commitlogsfromlastnight.com/">这里</a>，<a href="http://blog.no-panic.at/2014/10/20/funny-initial-git-commit-messages/">这里</a>和<a href="http://whatthecommit.com/">这里</a>）。</p>
<figure>
<img data-src="https://www.ruanyifeng.com/blogimg/asset/2016/bg2016010601.png" alt="" /><figcaption>img</figcaption>
</figure>
<p>但是，一般来说，commit message 应该清晰明了，说明本次提交的目的。</p>
<figure>
<img data-src="https://www.ruanyifeng.com/blogimg/asset/2016/bg2016010602.png" alt="" /><figcaption>img</figcaption>
</figure>
<p>目前，社区有多种 Commit message 的<a href="https://github.com/ajoslin/conventional-changelog/blob/master/conventions">写法规范</a>。本文介绍<a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0">Angular 规范</a>（见上图），这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。</p>
<h2 id="commit-message-的作用">Commit message 的作用</h2>
<p>格式化的Commit message，有几个好处。</p>
<p><strong>（1）提供更多的历史信息，方便快速浏览。</strong></p>
<p>比如，下面的命令显示上次发布后的变动，每个commit占据一行。你只看行首，就知道某次 commit 的目的。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> &lt;last tag&gt; HEAD --pretty=format:%s</span><br></pre></td></tr></table></figure>
</blockquote>
<figure>
<img data-src="https://www.ruanyifeng.com/blogimg/asset/2016/bg2016010604.png" alt="" /><figcaption>img</figcaption>
</figure>
<p><strong>（2）可以过滤某些commit（比如文档改动），便于快速查找信息。</strong></p>
<p>比如，下面的命令仅仅显示本次发布新增加的功能。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> &lt;last release&gt; HEAD --grep feature</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>（3）可以直接从commit生成Change log。</strong></p>
<p>Change Log 是发布新版本时，用来说明与上一个版本差异的文档，详见后文。</p>
<figure>
<img data-src="https://www.ruanyifeng.com/blogimg/asset/2016/bg2016010603.png" alt="" /><figcaption>img</figcaption>
</figure>
<h2 id="commit-message-的格式">Commit message 的格式</h2>
<p>每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">type</span>&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>其中，Header 是必需的，Body 和 Footer 可以省略。</p>
<p>不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。</p>
<h3 id="header">Header</h3>
<p>Header部分只有一行，包括三个字段：<code>type</code>（必需）、<code>scope</code>（可选）和<code>subject</code>（必需）。</p>
<p><strong>（1）type</strong></p>
<p><code>type</code>用于说明 commit 的类别，只允许使用下面7个标识。</p>
<blockquote>
<ul>
<li>feat：新功能（feature）</li>
<li>fix：修补bug</li>
<li>docs：文档（documentation）</li>
<li>style： 格式（不影响代码运行的变动）</li>
<li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li>
<li>test：增加测试</li>
<li>chore：构建过程或辅助工具的变动</li>
</ul>
</blockquote>
<p>如果<code>type</code>为<code>feat</code>和<code>fix</code>，则该 commit 将肯定出现在 Change log 之中。其他情况（<code>docs</code>、<code>chore</code>、<code>style</code>、<code>refactor</code>、<code>test</code>）由你决定，要不要放入 Change log，建议是不要。</p>
<p><strong>（2）scope</strong></p>
<p><code>scope</code>用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>
<p><strong>（3）subject</strong></p>
<p><code>subject</code>是 commit 目的的简短描述，不超过50个字符。</p>
<blockquote>
<ul>
<li>以动词开头，使用第一人称现在时，比如<code>change</code>，而不是<code>changed</code>或<code>changes</code></li>
<li>第一个字母小写</li>
<li>结尾不加句号（<code>.</code>）</li>
</ul>
</blockquote>
<h3 id="body">Body</h3>
<p>Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">More detailed explanatory text, <span class="keyword">if</span> necessary.  Wrap it to </span><br><span class="line">about 72 characters or so. </span><br><span class="line"></span><br><span class="line">Further paragraphs come after blank lines.</span><br><span class="line"></span><br><span class="line">- Bullet points are okay, too</span><br><span class="line">- Use a hanging indent</span><br></pre></td></tr></table></figure>
</blockquote>
<p>有两个注意点。</p>
<p>（1）使用第一人称现在时，比如使用<code>change</code>而不是<code>changed</code>或<code>changes</code>。</p>
<p>（2）应该说明代码变动的动机，以及与以前行为的对比。</p>
<h3 id="footer">Footer</h3>
<p>Footer 部分只用于两种情况。</p>
<p><strong>（1）不兼容变动</strong></p>
<p>如果当前代码与上一个版本不兼容，则 Footer 部分以<code>BREAKING CHANGE</code>开头，后面是对变动的描述、以及变动理由和迁移方法。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class="line"></span><br><span class="line"> To migrate the code follow the example below:</span><br><span class="line"></span><br><span class="line"> Before:</span><br><span class="line"></span><br><span class="line"> scope: &#123;</span><br><span class="line">   myAttr: <span class="string">&#x27;attribute&#x27;</span>,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> After:</span><br><span class="line"></span><br><span class="line"> scope: &#123;</span><br><span class="line">   myAttr: <span class="string">&#x27;@&#x27;</span>,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> The removed `inject` wasn<span class="string">&#x27;t generaly useful for directives so there should be no code using it.</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>（2）关闭 Issue</strong></p>
<p>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Closes <span class="comment">#234</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>也可以一次关闭多个 issue 。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Closes <span class="comment">#123, #245, #992</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="revert">Revert</h3>
<p>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以<code>revert:</code>开头，后面跟着被撤销 Commit 的 Header。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">revert: feat(pencil): add <span class="string">&#x27;graphiteWidth&#x27;</span> option</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Body部分的格式是固定的，必须写成<code>This reverts commit &lt;hash&gt;.</code>，其中的<code>hash</code>是被撤销 commit 的 SHA 标识符。</p>
<p>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的<code>Reverts</code>小标题下面。</p>
<h2 id="commitizen">Commitizen</h2>
<p><a href="https://github.com/commitizen/cz-cli">Commitizen</a>是一个撰写合格 Commit message 的工具。</p>
<p>安装命令如下。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g commitizen</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure>
</blockquote>
<p>以后，凡是用到<code>git commit</code>命令，一律改为使用<code>git cz</code>。这时，就会出现选项，用来生成符合格式的 Commit message。</p>
<figure>
<img data-src="https://www.ruanyifeng.com/blogimg/asset/2016/bg2016010605.png" alt="" /><figcaption>img</figcaption>
</figure>
<h2 id="validate-commit-msg">validate-commit-msg</h2>
<p><a href="https://github.com/kentcdodds/validate-commit-msg">validate-commit-msg</a> 用于检查 Node 项目的 Commit message 是否符合格式。</p>
<p>它的安装是手动的。首先，拷贝下面这个<a href="https://github.com/kentcdodds/validate-commit-msg/blob/master/index.js">JS文件</a>，放入你的代码库。文件名可以取为<code>validate-commit-msg.js</code>。</p>
<p>接着，把这个脚本加入 Git 的 hook。下面是在<code>package.json</code>里面使用 <a href="http://npm.im/ghooks">ghooks</a>，把这个脚本加为<code>commit-msg</code>时运行。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;config&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;ghooks&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;commit-msg&quot;</span>: <span class="string">&quot;./validate-commit-msg.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，每次<code>git commit</code>的时候，这个脚本就会自动检查 Commit message 是否合格。如果不合格，就会报错。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add -A </span><br><span class="line">$ git commit -m <span class="string">&quot;edit markdown&quot;</span> </span><br><span class="line">INVALID COMMIT MSG: does not match <span class="string">&quot;&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&quot;</span> ! was: edit markdown</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="生成-change-log">生成 Change log</h2>
<p>如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成（<a href="https://github.com/ajoslin/conventional-changelog/blob/master/CHANGELOG.md">例1</a>，<a href="https://github.com/karma-runner/karma/blob/master/CHANGELOG.md">例2</a>，<a href="https://github.com/btford/grunt-conventional-changelog/blob/master/CHANGELOG.md">例3</a>）。</p>
<p>生成的文档包括以下三个部分。</p>
<blockquote>
<ul>
<li>New features</li>
<li>Bug fixes</li>
<li>Breaking changes.</li>
</ul>
</blockquote>
<p>每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。</p>
<p><a href="https://github.com/ajoslin/conventional-changelog">conventional-changelog</a> 就是生成 Change log 的工具，运行下面的命令即可。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g conventional-changelog</span><br><span class="line">$ <span class="built_in">cd</span> my-project</span><br><span class="line">$ conventional-changelog -p angular -i CHANGELOG.md -w</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令不会覆盖以前的 Change log，只会在<code>CHANGELOG.md</code>的头部加上自从上次发布以来的变动。</p>
<p>如果你想生成所有发布的 Change log，要改为运行下面的命令。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conventional-changelog -p angular -i CHANGELOG.md -w -r 0</span><br></pre></td></tr></table></figure>
</blockquote>
<p>为了方便使用，可以将其写入<code>package.json</code>的<code>scripts</code>字段。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;changelog&quot;</span>: <span class="string">&quot;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>以后，直接运行下面的命令即可。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm run changelog</span><br></pre></td></tr></table></figure>
</blockquote>
<p>（完）</p>
]]></content>
      <categories>
        <category>参考与指南</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>转载</tag>
        <tag>规约</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>常见加密算法在Java中的使用</title>
    <url>/posts/ba2ea806.html</url>
    <content><![CDATA[<blockquote>
<p>转载信息：<a href="https://developer.aliyun.com/article/769289">面试官：说一下你常用的加密算法</a>（https://developer.aliyun.com/article/769289）<br />
原文作者：<a href="https://developer.aliyun.com/profile/expert/bqscd3m22yfak">Java旅途</a>（https://developer.aliyun.com/profile/expert/bqscd3m22yfak）<br />
版权声明：本文内容由阿里云实名注册用户自发贡献，版权归原作者所有，阿里云开发者社区不拥有其著作权，亦不承担相应法律责任。具体规则请查看《<a href="https://developer.aliyun.com/article/768092">阿里云开发者社区用户服务协议</a>》和《<a href="https://developer.aliyun.com/article/768093">阿里云开发者社区知识产权保护指引</a>》。如果您发现本社区中有涉嫌抄袭的内容，填写<a href="https://yida.alibaba-inc.com/o/right">侵权投诉表单</a>进行举报，一经查实，本社区将立刻删除涉嫌侵权内容。<br />
发表日期：2020年07月31日</p>
</blockquote>
<h2 id="转载注">转载注</h2>
<p>实际上<code>不可逆加密算法</code>与<code>可逆加密算法</code>这样的分类方式并不常见，文中所述的<code>不可逆加密算法</code>被称为<a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">密码散列函数（Cryptographic hash function）</a>，而 <a href="https://en.wikipedia.org/wiki/HMAC">HMAC(hash-based message authentication code)</a> 是一种<a href="https://en.wikipedia.org/wiki/Message_authentication_code">消息认证码（Message authentication code）</a> 需要使用密码散列函数（Cryptographic hash function）和自定义的密钥（secret key）计算得出。</p>
<hr />
<p>加密算法我们整体可以分为：可逆加密和不可逆加密，可逆加密又可以分为：对称加密和非对称加密。</p>
<h2 id="不可逆加密">不可逆加密</h2>
<p>常见的不可逆加密算法有<code>MD5</code>，<code>HMAC</code>，<code>SHA1</code>、<code>SHA-224</code>、<code>SHA-256</code>、<code>SHA-384</code>，和<code>SHA-512</code>，其中<code>SHA-224</code>、<code>SHA-256</code>、<code>SHA-384</code>，和<code>SHA-512</code>我们可以统称为<code>SHA2</code>加密算法，<code>SHA</code>加密算法的安全性要比<code>MD5</code>更高，而<code>SHA2</code>加密算法比<code>SHA1</code>的要高。其中<code>SHA</code>后面的数字表示的是加密后的字符串长度，<code>SHA1</code>默认会产生一个<code>160</code>位的信息摘要。</p>
<p>不可逆加密算法最大的特点就是密钥，但是<code>HMAC</code>是需要密钥的【手动狗头】。</p>
<p>由于这些加密都是不可逆的，因此比较常用的场景就是用户密码加密，其验证过程就是通过比较两个加密后的字符串是否一样来确认身份的。网上也有很多自称是可以破解<code>MD5</code>密码的网站，其原理也是一样，就是有一个巨大的资源库，存放了许多字符串及对应的<code>MD5</code>加密后的字符串，通过你输入的<code>MD5</code>加密串来进行比较，如果过你的密码复杂度比较低，还是有很大机率验证出来的。</p>
<h3 id="md5">MD5</h3>
<blockquote>
<p><strong>MD5信息摘要算法</strong>（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。</p>
</blockquote>
<p><code>MD5</code>算法有以下特点：</p>
<p>1、压缩性：无论数据长度是多少，计算出来的<code>MD5</code>值长度相同</p>
<p>2、容易计算性：由原数据容易计算出<code>MD5</code>值</p>
<p>3、抗修改性：即便修改一个字节，计算出来的<code>MD5</code>值也会巨大差异</p>
<p>4、抗碰撞性：知道数据和<code>MD5</code>值，很小概率找到相同<code>MD5</code>值相同的原数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">md5</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="type">MessageDigest</span> <span class="variable">messageDigest</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        messageDigest = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">byte</span>[] bytes = messageDigest.digest(text.getBytes());</span><br><span class="line">    <span class="keyword">return</span> Hex.encodeHexString(bytes); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sha系列">SHA系列</h3>
<blockquote>
<p><strong>安全散列算法</strong>（英语：Secure Hash Algorithm，缩写为SHA）是一个密码散列函数家族，是FIPS所认证的安全散列算法。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。且若输入的消息不同，它们对应到不同字符串的机率很高。</p>
<p>2005年8月17日的CRYPTO会议尾声中王小云、姚期智、姚储枫再度发表更有效率的SHA-1攻击法，能在2的63次方个计算复杂度内找到碰撞。</p>
</blockquote>
<p>也就是说<code>SHA-1</code>加密算法有碰撞的可能性，虽然很小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">sha256</span><span class="params">(String text)</span> &#123;</span><br><span class="line">    <span class="type">MessageDigest</span> <span class="variable">messageDigest</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        messageDigest = MessageDigest.getInstance(<span class="string">&quot;SHA-256&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">byte</span>[] bytes = messageDigest.digest(text.getBytes()); </span><br><span class="line">    <span class="keyword">return</span> Hex.encodeHexString(bytes); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hmac系列">HMAC系列</h3>
<blockquote>
<p>HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）的缩写，由H.Krawezyk，M.Bellare，R.Canetti于1996年提出的一种基于Hash函数和密钥进行消息认证的方法，并于1997年作为RFC2104被公布，并在<a href="https://baike.baidu.com/item/IPSec/2472311">IPSec</a>和其他网络协议（如<a href="https://baike.baidu.com/item/SSL/320778">SSL</a>）中得以广泛应用，现在已经成为事实上的Internet安全标准。它可以与任何迭代散列函数捆绑使用。</p>
<p>HMAC算法更像是一种加密算法，它引入了密钥，其安全性已经不完全依赖于所使用的Hash算法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">hmacSha256</span><span class="params">(String text, SecretKeySpec sk)</span> &#123;</span><br><span class="line">    <span class="type">Mac</span> <span class="variable">mac</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mac = Mac.getInstance(<span class="string">&quot;HmacSHA256&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mac.init(sk);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvalidKeyException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">byte</span>[] rawHmac = mac.doFinal(text.getBytes());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(Base64.encodeBase64(rawHmac));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要使用不可逆加密，推荐使用SHA256、SHA384、SHA512以及HMAC-SHA256、HMAC-SHA384、HMAC-SHA512这几种算法。</p>
<h2 id="对称加密算法">对称加密算法</h2>
<p>对称加密算法是应用比较早的算法，在数据加密和解密的时用的都是同一个密钥，这就造成了密钥管理困难的问题。常见的对称加密算法有<code>DES</code>、<code>3DES</code>、<code>AES128</code>、<code>AES192</code>、<code>AES256</code> (默认安装的 <code>JDK</code> 尚不支持 <code>AES256</code>，需要安装对应的 <code>jce</code> 补丁进行升级 <code>jce1.7</code>，<code>jce1.8</code>)。其中<code>AES</code>后面的数字代表的是密钥长度。对称加密算法的安全性相对较低，比较适用的场景就是内网环境中的加解密。</p>
<h3 id="des">DES</h3>
<p><code>DES</code>是对称加密算法领域中的典型算法，其密钥默认长度为<code>56</code>位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encrypt</span><span class="params">(<span class="type">byte</span>[] dataSource, String password)</span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">SecureRandom</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">         <span class="type">DESKeySpec</span> <span class="variable">desKeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DESKeySpec</span>(password.getBytes());</span><br><span class="line">         <span class="comment">//创建一个密匙工厂，然后用它把DESKeySpec转换成 </span></span><br><span class="line">         <span class="type">SecretKeyFactory</span> <span class="variable">secretKeyFactory</span> <span class="operator">=</span> SecretKeyFactory.getInstance(<span class="string">&quot;DES&quot;</span>); </span><br><span class="line">         <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> secretKeyFactory.generateSecret(desKeySpec); </span><br><span class="line">         <span class="comment">//Cipher对象实际完成加密操作 </span></span><br><span class="line">         <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;DES&quot;</span>); </span><br><span class="line">         <span class="comment">//用密匙初始化Cipher对象 </span></span><br><span class="line">         cipher.init(Cipher.ENCRYPT_MODE, secretKey, random); </span><br><span class="line">         <span class="comment">//正式执行加密操作 </span></span><br><span class="line">         <span class="keyword">return</span> Base64.encodeBase64String(cipher.doFinal(dataSource)); </span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable e) &#123; </span><br><span class="line">         e.printStackTrace(); </span><br><span class="line">     &#125; <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">decrypt</span><span class="params">(String src, String password)</span> <span class="keyword">throws</span> Exception&#123; </span><br><span class="line">    <span class="comment">// DES算法要求有一个可信任的随机数源 </span></span><br><span class="line">    <span class="type">SecureRandom</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>(); </span><br><span class="line">    <span class="comment">// 创建一个DESKeySpec对象 </span></span><br><span class="line">    <span class="type">DESKeySpec</span> <span class="variable">desKeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DESKeySpec</span>(password.getBytes()); </span><br><span class="line">    <span class="comment">// 创建一个密匙工厂 </span></span><br><span class="line">    <span class="type">SecretKeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> SecretKeyFactory.getInstance(<span class="string">&quot;DES&quot;</span>); </span><br><span class="line">    <span class="comment">// 将DESKeySpec对象转换成SecretKey对象 </span></span><br><span class="line">    <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> keyFactory.generateSecret(desKeySpec); </span><br><span class="line">    <span class="comment">// Cipher对象实际完成解密操作 </span></span><br><span class="line">    <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;DES&quot;</span>); </span><br><span class="line">    <span class="comment">// 用密匙初始化Cipher对象 </span></span><br><span class="line">    cipher.init(Cipher.DECRYPT_MODE, secretKey, random); </span><br><span class="line">    <span class="comment">// 真正开始解密操作 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(cipher.doFinal(Base64.decodeBase64(src))); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="des-1">3DES</h3>
<p><code>3DES</code>（即Triple DES）是<code>DES</code>向<code>AES</code>过渡的加密算法，它使用3条56位的密钥对数据进行三次加密。是<code>DES</code>的一个更安全的变形。它以<code>DES</code>为基本模块，通过组合分组方法设计出分组加密算法。比起最初的<code>DES</code>，<code>3DES</code>更为安全。密钥长度默认为<code>168</code>位，还可以选择<code>128</code>位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encryptThreeDESECB</span><span class="params">(String src, String key)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">DESedeKeySpec</span> <span class="variable">dks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DESedeKeySpec</span>(key.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">SecretKeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> SecretKeyFactory.getInstance(<span class="string">&quot;DESede&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">securekey</span> <span class="operator">=</span> keyFactory.generateSecret(dks);</span><br><span class="line"></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;DESede/ECB/PKCS5Padding&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, securekey);</span><br><span class="line">        <span class="type">byte</span>[] b = cipher.doFinal(src.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(Base64.encodeBase64(b));</span><br><span class="line">        ss = ss.replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;-&quot;</span>);</span><br><span class="line">        ss = ss.replaceAll(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;_&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ss;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">decryptThreeDESECB</span><span class="params">(String src, String key)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        src = src.replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;+&quot;</span>);</span><br><span class="line">        src = src.replaceAll(<span class="string">&quot;_&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytesrc = Base64.decodeBase64(src.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="comment">// --解密的key</span></span><br><span class="line">        <span class="type">DESedeKeySpec</span> <span class="variable">dks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DESedeKeySpec</span>(key.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">SecretKeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> SecretKeyFactory.getInstance(<span class="string">&quot;DESede&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">securekey</span> <span class="operator">=</span> keyFactory.generateSecret(dks);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --Chipher对象解密</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;DESede/ECB/PKCS5Padding&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, securekey);</span><br><span class="line">        <span class="type">byte</span>[] retByte = cipher.doFinal(bytesrc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(retByte, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="aes">AES</h3>
<p><code>AES</code> 高级数据加密标准，能够有效抵御已知的针对<code>DES</code>算法的所有攻击，默认密钥长度为<code>128</code>位，还可以供选择<code>192</code>位，<code>256</code>位。这里顺便提一句这个位指的是bit。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">defaultCharset</span> <span class="operator">=</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_AES</span> <span class="operator">=</span> <span class="string">&quot;AES&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_MD5</span> <span class="operator">=</span> <span class="string">&quot;MD5&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> MessageDigest md5Digest;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        md5Digest = MessageDigest.getInstance(KEY_MD5);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 加密</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encrypt</span><span class="params">(String data, String key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> doAES(data, key, Cipher.ENCRYPT_MODE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 解密</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">decrypt</span><span class="params">(String data, String key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> doAES(data, key, Cipher.DECRYPT_MODE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 加解密</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">doAES</span><span class="params">(String data, String key, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">encrypt</span> <span class="operator">=</span> mode == Cipher.ENCRYPT_MODE;</span><br><span class="line">        <span class="type">byte</span>[] content;</span><br><span class="line">        <span class="keyword">if</span> (encrypt) &#123;</span><br><span class="line">            content = data.getBytes(defaultCharset);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            content = Base64.decodeBase64(data.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(md5Digest.digest(key.getBytes(defaultCharset))</span><br><span class="line">                                                  , KEY_AES);</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(KEY_AES);<span class="comment">// 创建密码器</span></span><br><span class="line">        cipher.init(mode, keySpec);<span class="comment">// 初始化</span></span><br><span class="line">        <span class="type">byte</span>[] result = cipher.doFinal(content);</span><br><span class="line">        <span class="keyword">if</span> (encrypt) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(Base64.encodeBase64(result));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(result, defaultCharset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>推荐使用对称加密算法有：<code>AES128</code>、<code>AES192</code>、<code>AES256</code>。</p>
<h2 id="非对称加密算法">非对称加密算法</h2>
<p>非对称加密算法有两个密钥，这两个密钥完全不同但又完全匹配。只有使用匹配的一对公钥和私钥，才能完成对明文的加密和解密过程。常见的非对称加密有<code>RSA</code>、<code>SM2</code>等。</p>
<h3 id="rsa">RSA</h3>
<p><code>RSA</code>密钥至少为500位长，一般推荐使用1024位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非对称密钥算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_ALGORITHM</span> <span class="operator">=</span> <span class="string">&quot;RSA&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 密钥长度，DH算法的默认密钥长度是1024</span></span><br><span class="line"><span class="comment">  * 密钥长度必须是64的倍数，在512到65536位之间</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">KEY_SIZE</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//公钥</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PUBLIC_KEY</span> <span class="operator">=</span> <span class="string">&quot;RSAPublicKey&quot;</span>;</span><br><span class="line"><span class="comment">//私钥</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PRIVATE_KEY</span> <span class="operator">=</span> <span class="string">&quot;RSAPrivateKey&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 初始化密钥对</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> Map 甲方密钥的Map</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title function_">initKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//实例化密钥生成器</span></span><br><span class="line">    <span class="type">KeyPairGenerator</span> <span class="variable">keyPairGenerator</span> <span class="operator">=</span> KeyPairGenerator.getInstance(KEY_ALGORITHM);</span><br><span class="line">    <span class="comment">//初始化密钥生成器</span></span><br><span class="line">    keyPairGenerator.initialize(KEY_SIZE);</span><br><span class="line">    <span class="comment">//生成密钥对</span></span><br><span class="line">    <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGenerator.generateKeyPair();</span><br><span class="line">    <span class="comment">//甲方公钥</span></span><br><span class="line">    <span class="type">RSAPublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> (RSAPublicKey) keyPair.getPublic();</span><br><span class="line">    <span class="comment">//甲方私钥</span></span><br><span class="line">    <span class="type">RSAPrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> (RSAPrivateKey) keyPair.getPrivate();</span><br><span class="line">    <span class="comment">//将密钥存储在map中</span></span><br><span class="line">    Map&lt;String, Object&gt; keyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">    keyMap.put(PUBLIC_KEY, publicKey);</span><br><span class="line">    keyMap.put(PRIVATE_KEY, privateKey);</span><br><span class="line">    <span class="keyword">return</span> keyMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 私钥加密</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> data 待加密数据</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key  密钥</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> byte[] 加密数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encryptByPrivateKey(<span class="type">byte</span>[] data, <span class="type">byte</span>[] key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取得私钥</span></span><br><span class="line">    <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">pkcs8KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(key);</span><br><span class="line">    <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">    <span class="comment">//生成私钥</span></span><br><span class="line">    <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">    <span class="comment">//数据加密</span></span><br><span class="line">    <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">    cipher.init(Cipher.ENCRYPT_MODE, privateKey);</span><br><span class="line">    <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 公钥加密</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> data 待加密数据</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key  密钥</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> byte[] 加密数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encryptByPublicKey(<span class="type">byte</span>[] data, <span class="type">byte</span>[] key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化密钥工厂</span></span><br><span class="line">    <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">    <span class="comment">//初始化公钥</span></span><br><span class="line">    <span class="comment">//密钥材料转换</span></span><br><span class="line">    <span class="type">X509EncodedKeySpec</span> <span class="variable">x509KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(key);</span><br><span class="line">    <span class="comment">//产生公钥</span></span><br><span class="line">    <span class="type">PublicKey</span> <span class="variable">pubKey</span> <span class="operator">=</span> keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">    <span class="comment">//数据加密</span></span><br><span class="line">    <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">    cipher.init(Cipher.ENCRYPT_MODE, pubKey);</span><br><span class="line">    <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 私钥解密</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> data 待解密数据</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key  密钥</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> byte[] 解密数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decryptByPrivateKey(<span class="type">byte</span>[] data, <span class="type">byte</span>[] key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//取得私钥</span></span><br><span class="line">    <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">pkcs8KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(key);</span><br><span class="line">    <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">    <span class="comment">//生成私钥</span></span><br><span class="line">    <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">    <span class="comment">//数据解密</span></span><br><span class="line">    <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">    cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">    <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 公钥解密</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> data 待解密数据</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key  密钥</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> byte[] 解密数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decryptByPublicKey(<span class="type">byte</span>[] data, <span class="type">byte</span>[] key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化密钥工厂</span></span><br><span class="line">    <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">    <span class="comment">//初始化公钥</span></span><br><span class="line">    <span class="comment">//密钥材料转换</span></span><br><span class="line">    <span class="type">X509EncodedKeySpec</span> <span class="variable">x509KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(key);</span><br><span class="line">    <span class="comment">//产生公钥</span></span><br><span class="line">    <span class="type">PublicKey</span> <span class="variable">pubKey</span> <span class="operator">=</span> keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">    <span class="comment">//数据解密</span></span><br><span class="line">    <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">    cipher.init(Cipher.DECRYPT_MODE, pubKey);</span><br><span class="line">    <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 取得私钥</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> keyMap 密钥map</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> byte[] 私钥</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getPrivateKey(Map&lt;String, Object&gt; keyMap) &#123;</span><br><span class="line">    <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> (Key) keyMap.get(PRIVATE_KEY);</span><br><span class="line">    <span class="keyword">return</span> key.getEncoded();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 取得公钥</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> keyMap 密钥map</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> byte[] 公钥</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getPublicKey(Map&lt;String, Object&gt; keyMap) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> (Key) keyMap.get(PUBLIC_KEY);</span><br><span class="line">    <span class="keyword">return</span> key.getEncoded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="加密盐">加密盐</h2>
<p>加密盐也是比较常听到的一个概念，盐就是一个随机字符串用来和我们的加密串拼接后进行加密。加盐主要是为了提供加密字符串的安全性。假如有一个加盐后的加密串，黑客通过一定手段这个加密串，他拿到的明文，并不是我们加密前的字符串，而是加密前的字符串和盐组合的字符串，这样相对来说又增加了字符串的安全性。</p>
<p><strong>文中的一些算法来源于网络，可直接复制使用</strong>。</p>
<p>比较推荐的几个加密算法有：</p>
<ul>
<li>不可逆加密：<code>SHA256</code>、<code>SHA384</code>、<code>SHA512</code>以及<code>HMAC-SHA256</code>、<code>HMAC-SHA384</code>、<code>HMAC-SHA512</code></li>
<li>对称加密算法：<code>AES</code>、<code>3DES</code></li>
<li>非对称加密算法：<code>RSA</code></li>
</ul>
<figure>
<img data-src="https://img2020.cnblogs.com/blog/1719198/202007/1719198-20200731091157790-1639133777.jpg" alt="" /><figcaption>img</figcaption>
</figure>
]]></content>
      <categories>
        <category>参考与指南</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>加密算法</tag>
        <tag>消息摘要算法</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
</search>
